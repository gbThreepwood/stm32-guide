
************************************************************
STM32 Universal asynchronous receiver transmitter (UART) DMA
************************************************************

Reliable UART reception and transmission
========================================

The polling function :code:`HAL_UART_Receive (&huart1, rx_buffer, buffer_size, timeout_value);` is not suitable for anything but simple demo applications. There are two distinct features available which can allow us to implement reliable UART reception:

* RX complete Interrupt
* Direct memory access (DMA)

The interrupt approach is probably the most commonly used in embedded systems. It is less common for a microcontroller to support DMA, but when it does the DMA approach will allow the best performance. In this lesson we will cover the usage of DMA since it is supported by the STM32 microcontrollers.

Just like with reception, the most efficient way to transmit data over the UART is to use DMA. When sending we know how many bytes we are going to send in advance, which makes the implementation simpler. Still the data to transmit should be enqueued in a buffer, since the data rate of the UART can be much lower than the processing speed of the CPU.


Ring buffer
-----------

For reception the DMA can manage the data in a ring buffer. The CPU needs to keep track of the data which is new, and the data which has already been processed. In order to have a clean and consistent interface we will be keeping both the received data, and the data which we are going to send in software controlled ring buffers.

Although a ring buffer is something which is relatively straight forward to implement, it is better to rely on something which is thoroughly tested for production code. The ring buffer implementation we will be using here is called *lwrb*, and is available here: https://github.com/MaJerle/lwrb.


Generating the BSP using the low level (LL) drivers
---------------------------------------------------

We start by configuring as much as possible of the UART and DMA peripherals using CubeMX. We add configuration for both UART1, and UART2, but only DMA on UART1.

.. figure:: img/stm32wl55-pin-configuration-dual-uart-and-single-gpio.png

Use the following DMA configuration:

.. figure:: img/stm32wl55-uart1-dma-config.png

Configure both USART1, and USART2 for "asynchronous" mode, and enable interrupt. The rest of the parameters can remain in their default state.

Configuring and testing in a CMake project
------------------------------------------

.. The basics of how to create a CMake project using the stm32-cmake library is outlined in the article :ref:`Using STM32WL55 with CMake <stm32-basic-cmake-usage>`. You should follow that article until you have a working LED blinker, and make a copy of the LED blinker project which you use here. Name the project "wl55-uart-dma-demo".

Create two files "uart.c", and "uart.h" for the UART configuration. Copy the CubeMX generated UART initialization code in to some new functions which you place in "uart.c", with prototypes in "uart.h". Create two new files "dma.c", and "dma.h" where you place the DMA initialization code generated by CubeMX. You also need the system clock initialization, which you may place in "main.c".

Since we are using the low level (LL) library we have to make some changes to the CMakeLists.txt. The path to the various low level libraries are on the form of: :code:`HAL::STM32::WL::M4::LL_GPIO`.

.. warning:: I am still not 100% sure about the following CMake configuration. It works though.

.. code-block:: cmake

    set(HAL_COMP_LIST STM32WL LL_RCC LL_GPIO LL_USART LL_PWR LL_UTILS PWR CORTEX) # UART PWR CORTEX STM32WL)
    set(CMSIS_COMP_LIST STM32WL)

    find_package(CMSIS COMPONENTS "${CMSIS_COMP_LIST}" REQUIRED)
    find_package(HAL COMPONENTS "${HAL_COMP_LIST}" REQUIRED)

    add_executable(stm32wl55-uart-demo ${PROJECT_SOURCES})
    target_link_libraries(stm32wl55-uart-demo
        HAL::STM32::WL::M4::LL_RCC
        HAL::STM32::WL::M4::LL_PWR
        HAL::STM32::WL::M4::LL_GPIO
        HAL::STM32::WL::M4::LL_USART
        HAL::STM32::WL::M4::LL_UTILS
        CMSIS::STM32::WL55CC::M4
        STM32::NoSys
    )


Before we complete the configuration we should make sure that basic UART operation is functional. The following function will send messages on both UART devices:

.. code-block:: c

    void low_level_send_uart_message(){

    	char str1[] = "Hello from UART1\r\n";

    	for(uint8_t i = 0; i < strlen(str1); i++){
    		LL_USART_TransmitData8(USART1, str1[i]);
    		while(!LL_USART_IsActiveFlag_TXE_TXFNF(USART1)){};
    	}
        while (!LL_USART_IsActiveFlag_TC(USART1)) {}

    	char str2[] = "Hello from UART2\r\n";

    	for(uint8_t i = 0; i < strlen(str2); i++){
    		LL_USART_TransmitData8(USART2, str2[i]);
    		while(!LL_USART_IsActiveFlag_TXE_TXFNF(USART2)){};
    	}
        while (!LL_USART_IsActiveFlag_TC(USART2)) {}

    }

Add a call to this function in "main.c":

.. code-block:: c

    for(;;){ // ever...
     	LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_15);
	    LL_mDelay(500);
	    LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_15);
	    LL_mDelay(500);

	    low_level_send_uart_message();
    }

.. code-block:: console

    $ cmake ..
    $ make
    $ make flash

Use picocom (or your favorite UART terminal emulator) to observe the data received from the UART. Do not continue with the rest of this guide before you have made sure that this is working.


Implementing DMA support
------------------------

Most of the required initialization code for the UART, and DMA should already have been auto-generated from CubeMX, but there are a few important details missing and the peripheral is not yet activated.

The DMA needs to know which memory address it should use for the data received from the UART. It also needs to know the size of the buffer. The DMA is in circular mode, which means it will start overwriting the oldest data in the buffer, when it is full.

You need to declare memory for use by the DMA:

.. code-block:: c

    uint8_t usart1_rx_dma_buffer[64];

And configure the DMA to use this memory:

.. code-block:: c

    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_CHANNEL_1, LL_USART_DMA_GetRegAddr(USART1, LL_USART_DMA_REG_DATA_RECEIVE));
    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_1, (uint32_t)usart1_rx_dma_buffer);
    LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_1, sizeof(usart1_rx_dma_buffer) / sizeof(usart1_rx_dma_buffer[0]) );


Enable half transfer, and transfer complete interrupts for the DMA:

.. code-block:: c

    /* Enable half transfer & transfer complete interrupts */
    LL_DMA_EnableIT_HT(DMA1, LL_DMA_CHANNEL_1);
    LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_1);

Enable DMA request, and idle interrupt for USART1:

.. code-block:: c

    LL_USART_EnableDMAReq_RX(USART1);
    LL_USART_EnableIT_IDLE(USART1);

Enable DMA channel 1:

.. code-block:: c

  LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_1);

The interrupt service routines needs to be properly set up. The file "startup_stm32wl55ccux.s" is already prepared with function names for which we may provide the implementation.

.. code-block:: c

    void DMA1_Channel1_IRQHandler(void)
    {

      /* Half-transfer complete */
      if (LL_DMA_IsEnabledIT_HT(DMA1, LL_DMA_CHANNEL_1) && LL_DMA_IsActiveFlag_HT1(DMA1)) {
          LL_DMA_ClearFlag_HT1(DMA1);             /* Clear half-transfer complete flag */

        // Do something..
      }

      /* Transfer-complete */
      if (LL_DMA_IsEnabledIT_TC(DMA1, LL_DMA_CHANNEL_1) && LL_DMA_IsActiveFlag_TC1(DMA1)) {
          LL_DMA_ClearFlag_TC1(DMA1);             /* Clear transfer complete flag */

        // Do something..
      }

    }


.. code-block:: c

    void USART1_IRQHandler(void)
    {

      /* IDLE line interrupt */
      if (LL_USART_IsEnabledIT_IDLE(USART1) && LL_USART_IsActiveFlag_IDLE(USART1)) {
        LL_USART_ClearFlag_IDLE(USART1);        /* Clear IDLE line flag */

        // Do something..
      }

    }

For the initial test we will loop back the received data, but convert it to hexadecimal ASCII representation. I.e. the characters we send back are the ASCII characters representing the hexadecimal representation of the binary data which we have received. For now the transmission is performed in blocking mode:

.. code-block:: c

    void usart1_loopback_data(const void* data, size_t len) {
        const uint8_t* d = data;

        /*
         * This function is indirectly called on DMA TC or HT events, and on UART IDLE (if enabled) event.
         * A function void "usart1_check_for_rx(void)" first checks the state of the DMA buffer, and then
         * makes appropriate calls to this function.
         * 
         * For the sake of this example, function does a loop-back data over UART in polling mode.
         * Check ringbuff RX-based example for implementation with TX & RX DMA transfer.
         */
        char buf[7];

        for (; len > 0; --len, ++d) {

          snprintf(buf, 7, "[%#.2x]", *d); // snprintf always adds a null termination, hence use 7 as the size.

          for(uint8_t i = 0; i < 6; i++){
            //LL_USART_TransmitData8(USART1, *d);
            LL_USART_TransmitData8(USART1, buf[i]);
            while (!LL_USART_IsActiveFlag_TXE(USART1)) {}
          }
          while (!LL_USART_IsActiveFlag_TC(USART1)) {}
        }
    }

.. note:: Transmission through DMA will be handled after we have included the ring buffer.


The IRQ handlers for HT, TC, and IDLE must be set up to call the following function:

.. code-block:: c

    void usart1_check_for_rx(void) {
        static size_t old_pos;
        size_t pos;

        /* Calculate current position in buffer and check if new data is available */
        pos = ARRAY_LEN(usart1_rx_dma_buffer) - LL_DMA_GetDataLength(DMA1, LL_DMA_STREAM_0);

        if (pos != old_pos) {                       /* Check if new received data is available */

            if (pos > old_pos) {                    /* Check if current position is over previous one, i.e. DMA write to buffer did not wrap around */

                usart1_loopback_data(&usart1_rx_dma_buffer[old_pos], pos - old_pos); /* Process data linearly */

            } else { /* If pos is less than old_pos the DMA must have reached the end of the buffer, and wrapped around (circular mode) */

                usart1_loopback_data(&usart1_rx_dma_buffer[old_pos], ARRAY_LEN(usart1_rx_dma_buffer) - old_pos); /* Process from old_pos until end of buffer */

                if (pos > 0) {
                    usart1_loopback_data(&usart1_rx_dma_buffer[0], pos); /* Process from beginning of buffer until pos */
                }
            }
            old_pos = pos;                          /* Save current position as old_pos for the next iteration */
        }
    }

Make sure that everything up to this point is working before continuing with the next section. This includes using a ASCII table to verify that the output is in accordance with the keys that you are pressing on you keyboard.

.. code-block:: c

    $ make mon
    picocom v3.1

    port is        : /dev/mcu-uart1
    flowcontrol    : none
    baudrate is    : 115200
    parity is      : none
    databits are   : 8
    stopbits are   : 1
    escape is      : C-a
    local echo is  : no
    noinit is      : no
    noreset is     : no
    hangup is      : no
    nolock is      : no
    send_cmd is    : sz -vv
    receive_cmd is : rz -vv -E
    imap is        : 
    omap is        : 
    emap is        : crcrlf,delbs,
    logfile is     : none
    initstring     : none
    exit_after is  : not set
    exit is        : no

    Type [C-a] [C-h] to see available commands
    Terminal ready
    UART DMA demo application
    [0x61][0x73][0x64][0x66]
    Terminating...
    Skipping tty reset...
    Thanks for using picocom
    Built target mon

In the above example the keys pressed where 'a', 's', 'd', 'f'.

Adding ring buffer library
--------------------------

Create a new sub directory "lib" inside your top level project directory. Clone the *lwrb* library as a git submodule in to this directory:

.. code-block:: console

    git submodule add git@github.com:MaJerle/lwrb.git

Make the necessary additions to CMakeLists.txt for it to link the library to the project:

.. code-block:: cmake

    # Add subdir with lwrb and link to project
    add_subdirectory("lib/lwrb/lwrb" lwrb)
    target_link_libraries(${PROJECT_NAME} lwrb)

First we will test the library by adding some data to the buffer, and then reading it back.

.. code-block:: c

    void simple_lwrb_demo(){

        lwrb_t ringbuf;
        uint8_t ringbuf_data[16];
    
        lwrb_init(&ringbuf, ringbuf_data, sizeof(ringbuf_data));
    
        lwrb_write(&ringbuf, "Test msg", 9); // 9 bytes because of the zero terminator.
    
        printf("Number of bytes in the buffer: %d\r\n", lwrb_get_full(&ringbuf));
    
        char user_buffer[16];
        lwrb_read(&ringbuf, user_buffer, 9);
        printf("The buffer contains the text: %s\r\n", user_buffer);

    }

Since we are using :code:`printf()` we need to redirect the data to our UART. A simple but crude way of doing this is as follows:

.. code-block:: c

    int _write(int fd, char* ptr, int len){

	    for(uint8_t i = 0; i < len; i++){
	    	LL_USART_TransmitData8(USART1, *ptr++);
	    	while(!LL_USART_IsActiveFlag_TXE_TXFNF(USART1)){};
	    }
        while (!LL_USART_IsActiveFlag_TC(USART1)) {}

        return len;
    }

.. warning:: Note that the above code is blocking and should not be used in production code. In the next section we will send the :code:`printf()` traffic to the ring buffer, and transmit it using DMA.

Add a call to the :code:`simple_lwrb_demo()` function in your :code:`main()` function, and use a UART monitor to observe that the library is working.

After we have made sure that the *lwrb* library is working, the next step is to integrate it with our DMA code. The library is specifically designed for this integration, 

.. and allows the data transfer to happen without the CPU having to copy data to or from the *lwrb* buffer. Instead the DMA controller is configured to use the *lwrb* buffer memory address as destination or source depending on whether you are receiving or transmitting.

We are going to need two instances of the library for each UART that we are using. One for reception, and one for transmission.

.. code-block:: c

    lwrb_init(&usart1_tx_rb, usart1_tx_rb_data, sizeof(usart1_tx_rb_data));
    lwrb_init(&usart1_rx_rb, usart1_rx_rb_data, sizeof(usart1_rx_rb_data));



DMA transfer from UART to *lwrb*
--------------------------------

Unless we want to have an interrupt on every received byte, the DMA needs to have a separate receive buffer in addition to the *lwrb* receive buffer. That way we are free to wait for the DMA buffer to be filled to some level before some interrupt needs to process the data. The DMA is configured in circular mode, which means that it will start overwriting the oldest data in the buffer if receiving data after the buffer is full.

For implementing reliable reception of data from the UART we will be using three interrupts:

* USART idle line interrupt
* DMA half transfer interrupt
* DMA transfer complete interrupt

The idle line interrupt will ensure that the data in the DMA buffer is copied to our ring buffer as soon as the UART is idle. The half transfer and transfer complete interrupts copies the data from the DMA buffer when it is half full, and full. They are both needed since the buffer wraps around (circular mode) when it is full.

Declare memory for the ring buffer structure, and the actual buffer to hold received data:

.. code-block:: c

    lwrb_t usart1_rx_rb;
    uint8_t usart1_rx_rb_data[128];


Initialize the *lwrb*

.. code-block:: c

    void uart_init(){

      lwrb_init(&usart1_rx_rb, usart1_rx_rb_data, sizeof(usart1_rx_rb_data));
      usart1_init();

    }

In a similar manner to the previous example, all three interrupts will be calling the same function :code:`usart1_check_for_rx()` which is responsible for copying any received data from the DMA RX buffer to the *lwrb* RX buffer.

.. code-block:: c

    void usart1_check_for_rx(void) {
        static size_t old_pos;
        size_t pos;

        /* Calculate current position in buffer and check if new data is available */
        pos = ARRAY_LEN(usart1_rx_dma_buffer) - LL_DMA_GetDataLength(DMA1, LL_DMA_STREAM_0);

        if (pos != old_pos) {                       /* Check if new received data is available */

            if (pos > old_pos) {                    /* Check if current position is over previous one, i.e. DMA write to buffer did not wrap around */

                usart1_process_data(&usart1_rx_dma_buffer[old_pos], pos - old_pos); /* Process data linearly */

            } else { /* If pos is less than old_pos the DMA must have reached the end of the buffer, and wrapped around (circular mode) */

                usart1_process_data(&usart1_rx_dma_buffer[old_pos], ARRAY_LEN(usart1_rx_dma_buffer) - old_pos); /* Process from old_pos until end of buffer */

                if (pos > 0) {
                    usart1_process_data(&usart1_rx_dma_buffer[0], pos); /* Process from beginning of buffer until pos */
                }
            }
            old_pos = pos;                          /* Save current position as old_pos for the next iteration */
        }
    }

The process data function simply writes the DMA buffer data to the *lwrb* ring buffer:

.. code-block:: c

    void usart1_process_data(const void* data, size_t len) {
        lwrb_write(&usart1_rx_rb, data, len);  /* Write data to receive buffer */
    }



Checking for received data in application
-----------------------------------------

In order to check if new data is available from the UART one may use the following structure:

.. code-block:: c

    if (lwrb_read(&usart1_rx_rb, &rx_byte, 1) == 1) { // Check if data is available, and read one byte if it is.

        // Do something depending on the value of 'rx_byte'

    }

Use the following code to check that it is working:

.. code-block:: c

    if (lwrb_read(&usart1_rx_rb, &rx_byte, 1) == 1) { // Check if data is available, and read one byte if it is.

        if('A' == rx_byte){
          printf("You pressed A\r\n");
        }
        else if('B' == rx_byte){
          printf("You pressed B\r\n");
        }
        else{
          printf("You pressed something else...\r\n");
        }

    }


DMA transfer from *lwrb* to UART
--------------------------------

Up until this point the transmission of data from the microcontroller through the UART has been performed in blocking mode. I.e. the application has been waiting for the UART to complete transmission of all bytes before continuing with something else (:code:`while(!LL_USART_IsActiveFlag_TXE_TXFNF(USART1)){};`).

In this section we will add a second instance of the *lwrb* library which will enqueue data to be transmitted, and configure the DMA to transmit this data on request from the application.

The memory for the ring buffer is declared by:

.. code-block:: c

    lwrb_t usart1_tx_rb;
    uint8_t usart1_tx_rb_data[128];

The two ring buffers are initialized:

.. code-block:: c

    void uart_init(){

      lwrb_init(&usart1_rx_rb, usart1_rx_rb_data, sizeof(usart1_rx_rb_data));
      lwrb_init(&usart1_tx_rb, usart1_tx_rb_data, sizeof(usart1_tx_rb_data));

      usart1_init();
    }

The auto-generated DMA configuration code from CubeMX should look similar to the following:

.. code-block:: c

  /* USART1_TX Init */
  LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_2, LL_DMAMUX_REQ_USART1_TX);
  LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_2, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
  LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_2, LL_DMA_PRIORITY_LOW);
  LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_2, LL_DMA_MODE_NORMAL);
  LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_2, LL_DMA_PERIPH_NOINCREMENT);
  LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_2, LL_DMA_MEMORY_INCREMENT);
  LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_2, LL_DMA_PDATAALIGN_BYTE);
  LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_2, LL_DMA_MDATAALIGN_BYTE);
  LL_DMA_DisableChannelPrivilege(DMA1, LL_DMA_CHANNEL_2);

You need to add code to enable transfer complete interrupts:

.. code-block:: c

  /* Enable TC interrupts for TX */
  LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_2);

Set the interrupt priority:

.. code-block:: c

    NVIC_SetPriority(DMA1_Channel2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_EnableIRQ(DMA1_Channel2_IRQn);

Enable DMA request for TX:

.. code-block:: c

    LL_USART_EnableDMAReq_TX(USART1);

The DMA channel for TX should not be activated as part of the initialization (The RX channel is activated by the :code:`LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_1);` function call). Instead the tranmission should be activated by the application whenever it is time to transmit, and also by the DMA tranfer complete ISR for channel 2.

A global variable is used to keep track of the current length of data in the process of tranmission by the DMA:

.. code-block:: c
 
    volatile size_t usart1_tx_dma_current_len = 0;

It is used to determine if DMA tranmission is on going, or finished. If :code:`usart1_tx_dma_current_len == 0`, and there is currently data available in the *lwrb* transmission ring buffer a new DMA tranmission will be initiated.

The following function starts a new tranmission, and since the DMA is in normal mode it will stop itself once it reaches the end of the configured memory buffer.

.. code-block:: c

    uint8_t usart1_start_dma_tx(void) {
        uint32_t primask;
        uint8_t started = 0;

        primask = __get_PRIMASK();
        __disable_irq();

        if (usart1_tx_dma_current_len == 0){
          if ((usart1_tx_dma_current_len = lwrb_get_linear_block_read_length(&usart1_tx_rb)) > 0) {

              /* Disable channel if enabled */
              LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_2);

              /* Clear all flags */
              LL_DMA_ClearFlag_TC2(DMA1);
              LL_DMA_ClearFlag_HT2(DMA1);
              LL_DMA_ClearFlag_GI2(DMA1); // Clear global interrupt flag
              LL_DMA_ClearFlag_TE2(DMA1); // Clear transfer error flag

              /* Prepare DMA data and length */
              LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_2, usart1_tx_dma_current_len);
              LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_2, (uint32_t)lwrb_get_linear_block_read_address(&usart1_tx_rb));

              /* Start transfer */
              LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_2);
              started = 1;
          }
        }
  
        __set_PRIMASK(primask);
        return started;
    }

The ISR for the UART TX DMA is as follows:

.. code-block:: c

    void DMA1_Channel2_IRQHandler(void){

      /* Check transfer complete */
      if (LL_DMA_IsEnabledIT_TC(DMA1, LL_DMA_CHANNEL_2) && LL_DMA_IsActiveFlag_TC2(DMA1)) {
          LL_DMA_ClearFlag_TC2(DMA1);             /* Clear transfer complete flag */

          lwrb_skip(&usart1_tx_rb, usart1_tx_dma_current_len); /* Skip sent data, mark as read */

          usart1_tx_dma_current_len = 0;           /* Clear length variable */
          usart1_start_dma_tx();          /* Start sending more data */
      }
    }

Adding proper printf, scanf, and fprintf support
------------------------------------------------

We have already seen how :code:`printf()` can be directed to a specific UART device by overriding the low level :code:`_write()` function. The only difference this time is that we will be writing to the ring buffer, and return without having to wait for the UART to finish transmitting the data.

.. code-block:: c

    int _read(int file, char *ptr, int len) {
        
        return 0;
    }

    int _write(int file, char *ptr, int len) {
        
        return 0;
    }

The :code:`fprintf()` function takes a FILE object as the first parameter. This FILE object can be configured to point to a UART device. Since we are using more than one UART is is useful to be able to select where the data should go. This can be more convenient than the combination of declaring some buffer, fill it using a :code:`snprintf()` call, and then to have some low level UART transmit function. A single :code:`fprintf()` call is all that is needed.

The :code:`fopencookie()` function allows us to create a custom implementation for a I/O stream. It takes three arguments, a void pointer to a cookie, a mode, and a stucture of four I/O functions. The first parameter is intended to point to some custom structure which our custom I/O functions will be using, and can be :code:`NULL` for our purposes.

.. code-block:: c

    ssize_t cookie_uart_write(void *cookie, const char *buf, size_t size){

      lwrb_write(&usart1_tx_rb, buf, size);   /* Write data to transmit buffer */
      usart1_start_dma_tx();

      return size;
    }

.. code-block:: c

    FILE *uart1_stream;
    cookie_io_functions_t uart1_cookie_funcs = {
      .read = NULL,
      .write = cookie_uart_write,
      .seek = NULL,
      .close = NULL
    };

.. todo: Figure out how buffering works, just to make sure there is nothing funny going on here...

.. code-block:: c

    uart1_stream = fopencookie(NULL, "w", uart1_cookie_funcs);
    setlinebuf(uart1_stream); // Set line buffered mode on the stream

    fprintf(uart1_stream, "This is a test.\r\n");


Using a custom printf library
-----------------------------

The previous section explored how to use the GNU version of libc for :code:`printf()`. In this section we will use an alternative library which is specifically designed for embedded systems. The advantage is less memory consumption, fewer dependencies, and more easy redirection of the output. Since the library has zero non standard dependencies portability should not be an issue.

The repository for the printf library does not contain any CMakeLists.txt, so in order for us to add one we will be using the following directory structure:

.. code-block:: console

    .
    ├── libprintf
    │   ├── CMakeLists.txt
    │   └── printf
    │       ├── codecov.yml
    │       ├── LICENSE
    │       ├── Makefile
    │       ├── printf.c
    │       ├── printf.h
    │       ├── README.md
    │       └── test
    │           ├── catch.hpp
    │           └── test_suite.cpp
    └── lwrb

We create a new directory "libprintf" and clone the submodule in to that directory:

.. code-block:: console

    git submodule add git@github.com:mpaland/printf.git

Then we create a new CMakeLists.txt with the following contents, and place it in the "libprintf" directory:

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.22)

    # Debug message
    message("Entering ${CMAKE_CURRENT_LIST_DIR}/CMakeLists.txt")

    # Register core library
    add_library(libprintf INTERFACE)
    target_sources(libprintf PUBLIC ${CMAKE_CURRENT_LIST_DIR}/printf/printf.c)
    target_include_directories(libprintf INTERFACE ${CMAKE_CURRENT_LIST_DIR}/printf)

    # Register other modules

    # Debug message
    message("Exiting ${CMAKE_CURRENT_LIST_DIR}/CMakeLists.txt")

Finally we add our custom implementation of the :code:`_putchar` function to send the printf data to the UART:

.. code-block:: c

    void _putchar(char character)
    {
      lwrb_write(&usart1_tx_rb, &character, 1);   /* Write data to transmit buffer */
      usart1_start_dma_tx();
    }


The library does not support :code:`fprintf()`, but instead has a function :code:`fctprintf()` which takes a callback to an output function as the first parameter. This is not as powerful as the I/O stream of libc, but it is sufficient for a lot of applications.
